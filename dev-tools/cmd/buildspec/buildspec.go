// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License;
// you may not use this file except in compliance with the Elastic License.

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"text/template"

	lic "github.com/elastic/elastic-agent/dev-tools/licenses"
	"github.com/elastic/elastic-agent/pkg/packer"
)

var (
	flagSet *flag.FlagSet
	input   string
	output  string
	license string
)

func init() {
	// NOTE: This uses its own flagSet because dev-tools/licenses sets flags.
	flagSet = flag.NewFlagSet("buildspec", flag.ExitOnError)
	flagSet.StringVar(&input, "in", "", "Source of input. \"-\" means reading from stdin")
	flagSet.StringVar(&output, "out", "-", "Output path. \"-\" means writing to stdout")
	flagSet.StringVar(&license, "license", "Elastic", "License header for generated file.")
}

var tmpl = template.Must(template.New("specs").Parse(`
{{ .License }}
// Code generated by elastic-agent/internals/dev-tools/buildspec/buildspec.go - DO NOT EDIT.

package program

import (
	"strings"

	"github.com/elastic/elastic-agent/pkg/packer"
)

var Supported []Spec
var SupportedMap map[string]Spec

func init() {
	// Packed Files
	{{ range $i, $f := .Files -}}
	// {{ $f }}
	{{ end -}}
	unpacked := packer.MustUnpack("{{ .Pack }}")
	SupportedMap = make(map[string]Spec)

	for f, v := range unpacked {
	s, err:= NewSpecFromBytes(v)
		if err != nil {
			panic("Cannot read spec from " + f + ": " + err.Error())
		}
		Supported = append(Supported, s)
		SupportedMap[strings.ToLower(s.Cmd)] = s
	}
}
`))

func main() {
	if err := flagSet.Parse(os.Args[1:]); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v", err)
		os.Exit(1)
	}

	if len(input) == 0 {
		fmt.Fprintln(os.Stderr, "Invalid input source")
		os.Exit(1)
	}

	l, err := lic.Find(license)
	if err != nil {
		fmt.Fprintf(os.Stderr, "problem to retrieve the license, error: %+v", err)
		os.Exit(1)
	}

	data, err := gen(l)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error while generating the file, err: %+v\n", err)
		os.Exit(1)
	}

	if output == "-" {
		os.Stdout.Write(data)
		return
	} else {
		if err = ioutil.WriteFile(output, data, 0o600); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing data to file %q: %v\n", output, data)
			os.Exit(1)
		}
	}

	return
}

func gen(l string) ([]byte, error) {
	pack, files, err := packer.Pack(input)
	if err != nil {
		return nil, err
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, struct {
		Pack    string
		Files   []string
		License string
	}{
		Pack:    pack,
		Files:   files,
		License: l,
	})
	if err != nil {
		return nil, err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return nil, err
	}

	return formatted, nil
}
