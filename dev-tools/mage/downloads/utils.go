// Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
// or more contributor license agreements. Licensed under the Elastic License 2.0;
// you may not use this file except in compliance with the Elastic License 2.0.

package downloads

import (
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	devtools "github.com/elastic/elastic-agent/dev-tools/mage"

	"github.com/cenkalti/backoff/v4"
)

var checksumFileRegex = regexp.MustCompile(`^([0-9a-f]{128})\s+(\w.*)$`)

// downloadRequest struct contains download details ad path and URL
type downloadRequest struct {
	URL        string
	TargetPath string
}

// downloadFile will download a url and store it in a temporary path.
// It writes to the destination file as it downloads it, without
// loading the entire file into memory.
func downloadFile(downloadRequest *downloadRequest) error {
	stat, _ := os.Stat(downloadRequest.TargetPath)

	exp := getExponentialBackoff(3)

	retryCount := 1
	download := func() error {
		req, err := http.NewRequestWithContext(context.Background(), http.MethodGet, downloadRequest.URL, nil)
		if err != nil {
			return fmt.Errorf("creating request: %w", err)
		}
		// if the target file already exists, add the If-Modified-Since header
		if stat != nil {
			req.Header.Add("If-Modified-Since", stat.ModTime().Format(http.TimeFormat))
		}

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			retryCount++
			return fmt.Errorf("downloading file %s: %w", downloadRequest.URL, err)
		}
		defer func() {
			_ = resp.Body.Close()
		}()

		if resp.StatusCode == http.StatusNotModified {
			return nil
		}

		targetFile, err := os.Create(downloadRequest.TargetPath)
		if err != nil {
			return fmt.Errorf("creating file: %w", err)
		}
		defer func() {
			_ = targetFile.Close()
		}()

		_, err = io.Copy(targetFile, resp.Body)
		if err != nil {
			// try to drain the body before returning to ensure the connection can be reused
			_, _ = io.Copy(io.Discard, resp.Body)
			return fmt.Errorf("writing file %s: %w", targetFile.Name(), err)
		}

		_ = os.Chmod(targetFile.Name(), 0666)

		return nil
	}

	err := backoff.Retry(download, exp)
	if err != nil {
		return err
	}

	return nil
}

// verifyChecksum verifies a checksum file, with the content generated by the sha512sum program.
// The format is the hex encoded checksum, followed by a space, and then the filename.
// It is assumed that the files are in the same directory.
func verifyChecksum(checksumFile string) error {
	checksumFileContent, err := os.ReadFile(checksumFile)
	if err != nil {
		return fmt.Errorf("failed to read checksum file %s: %w", checksumFile, err)
	}
	strippedChecksumFileContent := strings.TrimSpace(string(checksumFileContent))
	matches := checksumFileRegex.FindStringSubmatch(strippedChecksumFileContent)
	if len(matches) != 3 {
		return fmt.Errorf("checksum file %s has invalid format, expected `{checksum} {filename}`", checksumFile)
	}
	expectedChecksum := matches[1]
	fileName := matches[2]

	filePath := filepath.Join(filepath.Dir(checksumFile), fileName)
	actualChecksum, err := devtools.GetSHA512Hash(filePath)
	if err != nil {
		return fmt.Errorf("failed to compute checksum of file %s: %w", fileName, err)
	}

	if expectedChecksum != actualChecksum {
		return fmt.Errorf("checksum of file %s does not match expected checksum of %s", fileName, actualChecksum)
	}

	return nil
}
