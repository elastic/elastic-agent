/*
 * fleet-server API
 *
 * The fleet-server API that is used by agents when enrolled with fleet.  Note that the current implementations in the fleet-server and elastic-agent may have some difference specifically when it comes to some objects. This is most notable when comparing the `Action` implementations. Fleet-server uses a general template for all actions and the elastic-agent will have more specific representations.  The implementation of fleet-server by default also includes a connection count limiter, as well as limiters for request body sizes. If an agent attempts to make request but there are no remaining connections, the attempt will be blocked and the agent will get an error. If an agent tries to send a body that is too large the fleet-server will respond with a 400 status code. 
 *
 * API version: 0.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

// Event - The ack for a specific action that the elastic-agent has executed.
type Event struct {

	// The event type of the ack. Not used by fleet-server. Currently the elastic-agent will only generate ACTION_RESULT events.
	Type string `json:"type"`

	// The subtype of the ack event. Not used by fleet-server. Currently the elastic-agent will only generate ACKNOWLEDGED events.
	Subtype string `json:"subtype"`

	// The ID of the agent that executed the action.
	AgentId string `json:"agent_id"`

	// The action ID.
	ActionId string `json:"action_id"`

	// The input_type of the action for input actions.
	ActionInputType string `json:"action_input_type"`

	// Not used by the fleet-server.
	PolicyId string `json:"policy_id"`

	// Not used by the fleet-server.
	StreamId string `json:"stream_id"`

	// The timestamp of the acknowledgement event. Has the format of \"2006-01-02T15:04:05.99999-07:00\"
	Timestamp string `json:"timestamp"`

	// An acknowlegement message. The elastic-agent inserts the action ID and action type into this message.
	Message string `json:"message"`

	// An embedded JSON object that contains additional information for the fleet-server to process. Defined as a json.RawMessage in both the fleet-server and the elastic-agent.  Is currently used by UPGRADE actions to signal retries. If the error attribute is non empty payload is checked for `retry: bool` and `retry_attempt: int`. If retry is true, fleet-serve will mark the agent as retrying, if it's false the upgrade will be marked as failed. 
	Payload string `json:"payload,omitempty"`

	// The time at which the action was started. Used only when acknowledging input actions.
	StartedAt string `json:"started_at"`

	// The time at which the action was completed. Used only when acknowledging input actions
	CompletedAt string `json:"completed_at"`

	// The action data for the input action being acknowledged.
	ActionData string `json:"action_data,omitempty"`

	// The action response for the input action being acknowledged.
	ActionResponse string `json:"action_response,omitempty"`

	// An embedded JSON object that has the data about the ack.  Used by REQUEST_DIAGNOSTICS actions. Contains a `upload_id` attribute used to communicate the successfullly uploaded diagnostics ID. 
	Data string `json:"data,omitempty"`

	// An error message. If this is non-empty an error has occured when executing the action. For some actions (such as UPGRADE actions) it may result in the action being marked as failed. 
	Error string `json:"error,omitempty"`
}

// AssertEventRequired checks if the required fields are not zero-ed
func AssertEventRequired(obj Event) error {
	elements := map[string]interface{}{
		"type": obj.Type,
		"subtype": obj.Subtype,
		"agent_id": obj.AgentId,
		"action_id": obj.ActionId,
		"action_input_type": obj.ActionInputType,
		"policy_id": obj.PolicyId,
		"stream_id": obj.StreamId,
		"timestamp": obj.Timestamp,
		"message": obj.Message,
		"started_at": obj.StartedAt,
		"completed_at": obj.CompletedAt,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	return nil
}

// AssertRecurseEventRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of Event (e.g. [][]Event), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseEventRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aEvent, ok := obj.(Event)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertEventRequired(aEvent)
	})
}
